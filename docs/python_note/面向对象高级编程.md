# 面向对象高级编程

## 使用__ slots __ 

> 只允许给类添加特定属性

```python
# 给类绑定属性
class Student(object):
    pass
s = Student()
s.name = 'Michael'

# 给实例绑定方法（对另外一个实例不起作用）
def set_age(self, age):
    self.age - age
from types import MethodType
s.set_age = MethodType(set_age, s)
s.set_age(25)
s.age # 调用age属性

# 给所有实例绑定方法，可以给class绑定方法（运行过程中，动态创建和修改类）
def set_score(self, score):
    self.score = score
Student.set_score = set_score

# 使用__slots__让类只允许添加name和age属性
class Student(object):
    __slots__ = ('name', 'age') # 用tuple来定义允许绑定的属性名称
# __slots__只对当前类的实例起作用，对继承的类不起作用
class GraduatesStudent(Student):
    pass
g = GraduateStudent()
s.score = 9999 # 仍然可以绑定一个score属性

```

## 使用@property

> 一种简化属性调用和修改的装饰器

### 不使用@property

> 能检查参数，但是定义不想直接访问和修改属性那样简单，所以就可以利用@property装饰器，可以将函数装饰城属性

```python
class Student(object):

    def get_score(self):
         return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
```

### 使用@property

```python
class Student(object):
# 这个其实是一个getter方法
    @property
    def score(self):
        return self._score
# 添加上setter方法
    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
        
# 添加只读属性
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value
# age是只读属性，因为没有setter方法。
    @property
    def age(self):
        return 2015 - self._birth
```

## 多重继承

```python
# 同时继承Mammal和Flyable
class Bat(Mammal, Flyable):
    pass
# Mixin设计模式，保证主干，混入功能。
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass

```

## 定制类

```python
# __str__()
class Student(object):
     def __init__(self, name):
         self.name = name
     def __str__(self):
         return 'Student object (name: %s)' % self.name
print(Student('Michael'))# 调用print()方法的时候，会调用__str__方法
s # 直接输入实例，仍然是没修改之前，是因为这个调用了__repr__()方法。
__repr__ = __str__ # 这样就可以实现，两种方式都一样的结果了

# __iter__
class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a > 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
# __getattr__
class Student(object):

    def __init__(self):
        self.name = 'Michael'
# 不错在属性，就返回99
    def __getattr__(self, attr):
        if attr=='score':
            return 99
# __call__ 让类像调用方法一样，调用类。
class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)

# 调用类
s = Student('Michael')
s() # 调用__call__定义的方法。

# 通过callable函数，来判断一个对象是否是可调用对象
callable(Student())

```

## 使用枚举类

```python
from enum import Enum

Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
for name, member in Month.__members__.items():
    print(name, '=>', member, ',', member.value) # 其中member.value返回的是int常量，默认是从1开始，nname是成员的名字。
# 通过继承Enum类，来自定义枚举类
from enum import Enum, unique
# 通过装饰器@unique来帮助我们检查保证没有重复值
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
```

## 使用元类

```python
# 使用type类，来定义类
Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
```

