# 面向对象高级编程

## 使用__ slots __ 

> 只允许给类添加特定属性

```python
# 给类绑定属性
class Student(object):
    pass
s = Student()
s.name = 'Michael'

# 给实例绑定方法（对另外一个实例不起作用）
def set_age(self, age):
    self.age - age
from types import MethodType
s.set_age = MethodType(set_age, s)
s.set_age(25)
s.age # 调用age属性

# 给所有实例绑定方法，可以给class绑定方法（运行过程中，动态创建和修改类）
def set_score(self, score):
    self.score = score
Student.set_score = set_score

# 使用__slots__让类只允许添加name和age属性
class Student(object):
    __slots__ = ('name', 'age') # 用tuple来定义允许绑定的属性名称
# __slots__只对当前类的实例起作用，对继承的类不起作用
class GraduatesStudent(Student):
    pass
g = GraduateStudent()
s.score = 9999 # 仍然可以绑定一个score属性

```

## 使用@property

> 一种简化属性调用和修改的装饰器

### 不使用@property

> 能检查参数，但是定义不想直接访问和修改属性那样简单，所以就可以利用@property装饰器，可以将函数装饰城属性

```python
class Student(object):

    def get_score(self):
         return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
```

### 使用@property

```python
class Student(object):
# 这个其实是一个getter方法
    @property
    def score(self):
        return self._score
# 添加上setter方法
    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value < 0 or value > 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
        
# 添加只读属性
class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value
# age是只读属性，因为没有setter方法。
    @property
    def age(self):
        return 2015 - self._birth
```

## 多重继承

```python
# 同时继承Mammal和Flyable
class Bat(Mammal, Flyable):
    pass
# Mixin设计模式，保证主干，混入功能。
class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass

```

## 定制类

```python
# __str__()
class Student(object):
     def __init__(self, name):
         self.name = name
     def __str__(self):
         return 'Student object (name: %s)' % self.name
print(Student('Michael'))# 调用print()方法的时候，会调用__str__方法
s # 直接输入实例，仍然是没修改之前，是因为这个调用了__repr__()方法。
__repr__ = __str__ # 这样就可以实现，两种方式都一样的结果了

# __iter__

```

