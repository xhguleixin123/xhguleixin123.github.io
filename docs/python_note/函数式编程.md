# 函数式编程

> 允许把函数本身作为参数传入另一个参数，还允许返回一个函数

## 高阶函数

> 把函数作为变量，传入函数，即参数是函数的函数就是高阶函数。

```python
# 变量可以指向函数
f = abs
f(-10)
# 函数名也可以是变量
abs = 10 # 此时abs指向的就是10，而不是函数abs()
# 传入函数
def add(x, y, f):
    return f(x) + f(y)
x = -5
y = 6
f = abs
add(x,y,f)
```

### map/reduce函数

* map函数

```python
def f(x):
    return x * x
# map将传入的f，依次作用到list中的每一个元素
r = map(f, [1. 2, 3, 4, 5, 6, 7, 8, 9])
# r是一个Iterator，所以必须强制转换成list
list(r)

# 将数字转换成字符
list(map(str, [1. 2, 3, 4, 5, 6, 7, 8, 9]))
```

* reduce函数

```python
# 其实reduce等价于
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
# 将序列转化成整数
from functools import reduce
def fn(x,y):
    return x * 10 + y
reduce(fn, [1,3,5,7,9])
```

### filter函数

```python
# true的留下，false的去处
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
```

### sorted函数

```python
# 按大小排序
sorted([36,5,-12,9,-21])
# 按照去绝对值之后再排序
sorted([36,5,-12,9,-21],key=abs)
# 按照ASCII码进行排序
sorted(['bob', 'about', 'Zoo', 'Credit'])
# 不考虑大小写进行排序
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)
# 反向排序
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
```

## 返回函数

```python
# 返回一个求和的函数
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
f = lazy_sum(1,3,5,7,9)
f() # 在调用f函数的时候，才真正计算求和的结果
# 就算两次调用的参数的相同，返回的函数不相同
f1 = lazy_sum(1, 3, 5, 7, 9)
f2 = lazy_sum(1, 3, 5, 7, 9)
# f1和f2互不影响

# 闭包
def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
# 实际调用时的函数引用了i,所以是指向i = 3,故输出都一样。
```

### 匿名函数

```python
list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
# 其中lambda相当于
def f(x):
    return x * x
# 将匿名表达式赋值给变量
f = lambda x: x * xf = lambda x: x * x
f(5)
# 将匿名函数返回
def build(x, y):
    return lambda: x * x + y * y
```

### 装饰器

> 在不修改函数本身的前提下，再补充函数的功能

```python
# 双层嵌套的装饰器
def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
@log
def now():
    print('2015-3-25')
# 实际效果
now = log(now) # now指向的是wrapper()函数,即装饰过后的函数

# 三层嵌套的装饰器
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func) # 使得装饰过后的函数名还是函数本身的函数名。
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
# 实际效果是
now = log('execute')(now)
# 先执行now = log('execute'),返回decorator，再执行decorator(now)，所以now，指向的还是wrapper()函数
```

### 偏函数

```python
import functools
in2 - functools.partial(int,base = 2) # 二进制装换
#　实际的效果是
kv = {'base':2}
int('10010', **kv)
# 就是将一个参数固定下来了
max2 = functools.partial(max, 10) # 将10永远固定在max的参数里。
# 实际效果
max2(5, 6, 7)
# 相当于
args = (10, 5, 6, 7)
max(*args)
```



