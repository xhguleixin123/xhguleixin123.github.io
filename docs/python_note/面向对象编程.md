# 面向对象编程

## 类和实例

```python
class Student(object):
    def __init__(self, name, score): # 构造方法，类的方法第一个参数必须是self
        self.name = name # 数据封装
        self.score = score 


bart = Student(name, score) # 实例化Student类
```

## 访问限制

```python
class Student(object):

    def __init__(self, name, score):
        self.__name = name # 私有变量
        self.__score = score
    def set_score(self, score): # 通过函数来读取和写入私有变量，并通过条件判断来避免传入无效的参数
        if 0 <= score <= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
    
bart._Student__name # 当创建好私有变量时，解释器会自动把私有变量的名字改成_Student__name，其实还是可以读取的
bart.__name = 'New Name' # 表面上看起来是设置了私有变量，但其实只是单纯的新设置了一个变量，原来的私有变量没有被改变。
```

## 继承和多态

> 多态就是，只要你知道父类有什么属性，就可以放心大胆的调用父类中的属性。
>
> 一个类，可以向上寻找不同类型的父类，所以可以被看成多种状态，故称为多态。
>
> ```ascii
>                 ┌───────────────┐
>                 │    object     │
>                 └───────────────┘
>                         │
>            ┌────────────┴────────────┐
>            │                         │
>            ▼                         ▼
>     ┌─────────────┐           ┌─────────────┐
>     │   Animal    │           │    Plant    │
>     └─────────────┘           └─────────────┘
>            │                         │
>      ┌─────┴──────┐            ┌─────┴──────┐
>      │            │            │            │
>      ▼            ▼            ▼            ▼
> ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐
> │   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │
> └─────────┘  └─────────┘  └─────────┘  └─────────┘
> ```

```python
# 所有的类继承自object类
class Animal(object): 
    def run(self):
        print('Animal is running...')
# 继承自Animal类的Dog类（Dog类可以放心大胆的调用Animal中run()方法）        
class Dog(Animal):

    def run(self):
        print('Dog is running...')

    def eat(self):
        print('Eating meat...')
        
```

## 静态语言 vs 动态语言

* 对于静态语言，若果需要传入一个Animal类，则需要传入的必须是Animal类，或者其子类，否则无法调用run()方法
* 对于python动态语言来说，不一定需要传入Animal类，可以是和Animal类有相同属性的类，就可以看做是相似类。

## 获取对象信息

```python
type(123)==type(456) # 获取对象类型，并判断类是否相同
type(abs)==types.BuiltinFunctionType # 使用types模块中定义的常量来判断函数是什么函数
isinstance(h, Husky) # 使用isinstance()方法来判断类是什么类型
isinstance([1, 2, 3], (list, tuple)) # 判断是否是后面类型中的一种
dir('ABC') # 判断类含有的属性和方法
# 使用len()方法时，自动调用__len__()属性，如果类自己有__len__属性，则可以使用len()方法来调用。
len('ABC')
'ABC'.__len__()

hasattr(obj, 'x') # 判断类是否有属性 'x'
setattr(obj, 'y', 19) # 设置属性
getattr(obj, 'y') # 获取属性
getattr(obj, 'z', 404) # 若属性不存在会报错，故设置一个错误返回值。
fn = getattr(obj, 'power') # 可以获取方法
```

## 实例属性和类属性

```python
class Student(object):
    name = 'Student' # 在类中定义类属性
    
s.name = 'Michael' # 给实例绑定一个新的name属性，就无法访问类属性name
del s.name # 删除实例属性之后就可以访问类属性了。
```

