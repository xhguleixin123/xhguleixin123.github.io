# 面向对象的设计原则

## 开闭原则(Open Close Principle, OCP)

> 对拓展开放，对修改封闭

```csharp
interface Icourse {
    
    String GetName{
        get;
    }
    float GetPrice{
        get;
    }
}
// 创建JavaCourse继承自Icourse接口
public class JavaCourse : Icourse {
    private string name;
    private float price;
    public JavaCourse(string _name, float _price){
        name = _name;
        price = _price;
    }
    public string GetName{
        get {
            return name;
        }
    }
    public float GetPrice{
        get {
            return price;
        }
    }
}
//若需要拓展一个GetDiscountPrice()的方法时，不能修改原来的类方法，只需要新建一个DiscountJavaCourse类，并且在DiscountJavaCourse类中添加GetDiscountPrice()方法就行。
public class DiscountJavaCourse : JavaCourse {
    public DiscountJavaCourse(string _name, float _price) : base(_name, _price){
        pass;
    }
    public float GetDiscountPrice(){
        return this.GetPrice * 0.8f;
    }
}
//利用拓展之后的类，实现类的方法的拓展。
Icourse iCourse = new JavaDiscountCourse("Java", 95);
```

## 单一职责原则

> * 不要存在多于一个导致类变更的原因。
> * 一个类/接口/方法只负责一项职责。

* 优点：降低复杂度、提高可读性、提高系统的可维护性、降低更改难度。
* 缺点：一味追求单一职责，有时会引起类的大爆炸，不过接口和方法应该遵循这个原则。

```csharp
//一个类中方法负责两个职责，如果需要拓展，则需要修改代码，所以将职能单一化。
public class Bird {
    public void MainMoveMode(string birdName){
    	if(birdName == "鸵鸟"){
        	Console.WriteLine("用脚走");
    	}
    	else {
        	Console.WriteLine("用翅膀飞");
    	}
    }
}
//所以分出一个单一职能的类。
public class FlyBird : Bird {
    private string bridName;
    public void FlyBird(string _birdName){
        birdName = _birdName;
    }
    public void MainMoveMode() {
        Console.WriteLine("用翅膀飞");
    }
}
public class WalkBird : Bird {
    private string bridName;
    public void FlyBird(string _birdName){
        birdName = _birdName;
    }
    public void MainMoveMode() {
        Console.WriteLine("用脚走");
    }
}
```

## 依赖倒置原则(Dependence Inversion Principle, DIP)

* 最核心的就是，模块之间的依赖必须建立在抽象的基础上。

> 依赖倒置，就是面向抽象编程，每个逻辑都应该依赖于抽象（接口和抽象类），即将物体倒过来，依赖于最本质的规则。抽象就是一套规则。
>
> 抽象就是对现实的约束，即，所有复杂的战术都是依赖于最简单的规则，并受牵制于规则，大家脱离了规则，就无法顺利进行。
>
> 依赖倒置就是，通过现象看本质。

### 通过构造函数传递依赖对象

```csharp
interface IDriver {
    void drive();
}
interface ICar {
    void run();
}

public class Driver : IDriver{
    private ICar car;
    // 在构造函数中添加依赖对象，ICar。注入！
    public void Driver(Icar _car){
        this.car = car;
    }
    public void drive(){
        this.car.run();
    }
}
```

### 接口中声明依赖对象

```csharp
interface IDriver {
    // 注入依赖
    void SetCar(ICar car);
    void drive();
}
interface ICar {
    void run();
}

public class Driver : IDriver{
    private ICar car;
    // 在构造函数中添加依赖对象，ICar。
    public void SetCar(Icar _car){
        this.car = car;
    }
    public void drive(){
        this.car.run();
    }
}
```

## 里式替换原则(Liskov Substitution Principle， LSP)

