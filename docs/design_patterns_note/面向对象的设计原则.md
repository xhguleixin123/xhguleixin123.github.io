# 面向对象的设计原则

## 开闭原则(Open Close Principle, OCP)

> 对拓展开放，对修改封闭

```csharp
interface Icourse {
    
    String GetName{
        get;
    }
    float GetPrice{
        get;
    }
}
// 创建JavaCourse继承自Icourse接口
public class JavaCourse : Icourse {
    private string name;
    private float price;
    public JavaCourse(string _name, float _price){
        name = _name;
        price = _price;
    }
    public string GetName{
        get {
            return name;
        }
    }
    public float GetPrice{
        get {
            return price;
        }
    }
}
//若需要拓展一个GetDiscountPrice()的方法时，不能修改原来的类方法，只需要新建一个DiscountJavaCourse类，并且在DiscountJavaCourse类中添加GetDiscountPrice()方法就行。
public class DiscountJavaCourse : JavaCourse {
    public DiscountJavaCourse(string _name, float _price) : base(_name, _price){
        pass;
    }
    public float GetDiscountPrice(){
        return this.GetPrice * 0.8f;
    }
}
//利用拓展之后的类，实现类的方法的拓展。
Icourse iCourse = new JavaDiscountCourse("Java", 95);
```

## 单一职责原则（Single Responsibility Principle，SRP）

> * 不要存在多于一个导致类变更的原因。
> * 一个类/接口/方法只负责一项职责。

* 优点：降低复杂度、提高可读性、提高系统的可维护性、降低更改难度。
* 缺点：一味追求单一职责，有时会引起类的大爆炸，不过接口和方法应该遵循这个原则。

```csharp
//一个类中方法负责两个职责，如果需要拓展，则需要修改代码，所以将职能单一化。
public class Bird {
    public void MainMoveMode(string birdName){
    	if(birdName == "鸵鸟"){
        	Console.WriteLine("用脚走");
    	}
    	else {
        	Console.WriteLine("用翅膀飞");
    	}
    }
}
//所以分出一个单一职能的类。
public class FlyBird : Bird {
    private string bridName;
    public void FlyBird(string _birdName){
        birdName = _birdName;
    }
    public void MainMoveMode() {
        Console.WriteLine("用翅膀飞");
    }
}
public class WalkBird : Bird {
    private string bridName;
    public void FlyBird(string _birdName){
        birdName = _birdName;
    }
    public void MainMoveMode() {
        Console.WriteLine("用脚走");
    }
}
```

## 依赖倒置原则(Dependence Inversion Principle, DIP)

* 最核心的就是，模块之间的依赖必须建立在抽象的基础上。

> 依赖倒置，就是面向抽象编程，每个逻辑都应该依赖于抽象（接口和抽象类），即将物体倒过来，依赖于最本质的规则。抽象就是一套规则。
>
> 抽象就是对现实的约束，即，所有复杂的战术都是依赖于最简单的规则，并受牵制于规则，大家脱离了规则，就无法顺利进行。
>
> 依赖倒置就是，通过现象看本质。

### 通过构造函数传递依赖对象

```csharp
interface IDriver {
    void drive();
}
interface ICar {
    void run();
}

public class Driver : IDriver{
    private ICar car;
    // 在构造函数中添加依赖对象，ICar。注入！
    public void Driver(Icar _car){
        this.car = car;
    }
    public void drive(){
        this.car.run();
    }
}
```

### 接口中声明依赖对象

```csharp
interface IDriver {
    // 注入依赖
    void SetCar(ICar car);
    void drive();
}
interface ICar {
    void run();
}

public class Driver : IDriver{
    private ICar car;
    // 在构造函数中添加依赖对象，ICar。
    public void SetCar(Icar _car){
        this.car = car;
    }
    public void drive(){
        this.car.run();
    }
}
```

## 里式替换原则(Liskov Substitution Principle， LSP)

> 在一个程序中，以父类定义的对象，被子类代替，程序的行为不发生改变
>
> 子类必须能替代他们的基类型

### 继承的缺陷

> 继承过程中，如多两个类是相互继承的，当一个子类的方法重写后，若出错，则在利用子类代替父类的程序中，会影响整个程序的行为。

```csharp
public class A{
    public int func1(int a, int b){
        return a-b;
    }
}

public class B{
    //在重写过程中不小心写错了方法。
    public int func1(int a, int b){
        return a+b;
    } 
    
    public int func2(int a, int b){
        return func1(a,b) + 100;
    }
}
```

### 里式替换原则四个深层含义

* 子类必须完全实现父类的方法，但不能覆盖（重写）父类的非抽象方法（能够重构，同名但不同参）。
* 子类可以增加自己特有的方法
* 当子类的方法重载父类的方法时，子类方法的前置条件（即方法的形参）要比父类的方法的输入参数更加宽泛。
* 当子类的方法实现父类的方法时，方法的后置条件（即方法的返回值）要比父类更加严格。

```csharp
public abstract class A{
    public abstract void run();
    public abstract void fly();
    public void walk(){
        pass;
    }
}
public class B : A{
    // 最好是面向抽象编程
    public void run(){
        pass;
    }
    public void fly(){
        pass;
    }
}

public class Father{
    public Collection doSomething(HashMap map){
        Console.WriteLine("父类被执行");
        return map.value();
    }
}

public class Son : Father{
    // 子类重载的方法的参数必须必父类的更加严格
    public Collection doSomething(Map map){
        Console.WriteLine("子类被执行");
        return map.value();
    }
}
```

### 总结

> 父类和子类若都是非抽象类，且父类的方法被子类重写，这样父类和子类会造成强耦合，所以尽量从不可实例的抽象父类继承，即面向接口和抽象编程。